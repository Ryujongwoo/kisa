#include <stdio.h>

int main(int argc, char* argv[]) {

	int a = 100; // 일반 변수 => 데이터(상수)를 기억한다.

//	포인터란 변수나 배열이 메모리에 선언된 주소를 의미한다. => 주소를 기억하는 변수를 포인터 변수라 부른다.
//	포인터 변수는 선언할 때 컴파일러에게 포인터 변수임을 알려주기 위해서 변수의 이름 앞에 "*"을 붙여서
//	선언한다.

//	"&"와 "*"가 단항 연산자로 사용될 경우
//	"&" => 번지 연산자, C++에서 변수 선언시 사용하면 참조 변수 선언을 의미한다.
//	"*" => 참조 연산자, C/C++에서 변수 선언시 사용하면 포인터 변수 선언을 의미한다.
// 
//	int* p; // 포인터 변수 => 포인터 변수를 선언만 했으므로 포인터 변수에는 쓰레기가 들어있다.
//	printf("%p\n", p); // 포인터 변수에 쓰레기가 들어있기 때문에 에러가 발생된다.
	
//	포인터 변수 선언시 아무값도 넣치 않고 선언하려면 NULL(꼭 대문자로)로 초기화 시키면 된다.
	int* p1 = NULL;
	printf("%p\n", p1); // 00000000
	printf("======================================\n");

//	포인터 선언시 붙이는 자료형 포인터 변수에 주소를 저장할 변수나 배열의 자료형을 적어주면 되고 변수
//	선언시 붙이는 자료형에 관계없이 포인터 변수의 크기는 무조건 4byte 이다.
	int* p2 = NULL;
	printf("포인터 변수의 크기: %d byte\n", sizeof(p2));
	printf("======================================\n");


//	포인터 변수는 데이터(상수)를 기억하지 않고 포인터(주소)를 기억하는 변수를 말한다. => 데이터를 넣으면
//	에러가 발생되었으나... 비쥬얼 스튜디오가 업데이터 된후 에러는 발생되지 않지만 사용하면 안된다.
	int* p3 = 100; // 에러는 아니고 100이 주소값으로 변환되서 들어간다.
	printf("%p\n", p3);
	int* p4 = a; ; // 에러는 아니고 변수 a에 저장된 값 100이 주소값으로 변환되서 들어간다.
	printf("%p\n", p4);

	int* p5 = &a;
	printf("%p\n", p5);
	printf("======================================\n");

	int data[] = { 1, 2, 3, 4, 5 };
	int* p6 = &data[0];
	printf("%p\n", p6);
	int* p7 = data; // 포인터 변수에 배열 이름을 넣을때는 "&"를 붙이지 않아도 상관없다.
	printf("%p\n", p7);

}